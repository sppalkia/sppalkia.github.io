<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>Implementing Weld in Rust</title>
  <meta name="description" content="The Stanford DAWN blog.">

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/blog/css/main.css">

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="img/favicon.png">

</head>


<body>
	<div id="wrap">
	  	
	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="/blog/">Home</a>

		<!-- Nav pages -->
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
    
    <!-- Nav links -->
	  <a href=/blog>Blog</a>



	</div>
  
  <!-- Nav footer -->
	
	  <footer>
	
	<span>version 1.0.0</span>

</footer>
	

</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">  
      <a href="http://dawn.cs.stanford.edu/">
        <h1>
          <span>Stanford</span> DAWN
        </h1>
      </a>
    </span>
    <span id="nav-links" class="absolute right bottom">
      <!-- Nav pages -->
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
      
      <!-- Nav links -->
	    <a href=/blog>Blog</a>



    </span>
  </div>
</header>




      

    <!-- Main content -->
	  <div id="container">
		  
		<main>

			<article id="post-page">
	<h2>Implementing Weld in Rust</h2>		
    <i><h7>by Shoumik Palkar, Deepak Narayanan, James Thomas, and Matei Zaharia</h7></i>		
	<time datetime="2017-03-26T00:00:00-04:00" class="by-line">26 Mar 2017</time>
	<div class="content">

		<p><a href="https://weld-project.github.io">Weld</a> is a runtime and language for high performance data analytics, developed
in the Stanford Infolab. It is implemented
in <a href="https://www.rust-lang.org">Rust</a>, a modern take on a fast systems
programming language. In this blog post we provide our experiences
implementing a low-level systems research project in Rust (with no prior
experience with the language). We hope this will help other developers evaluate
Rust when choosing a language for their system.</p>

<p>First, a bit of background on Weld. The Weld
language includes common functional operators like <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">reduce</code>,
and <code class="highlighter-rouge">groupBy</code>. Writers of analytics libraries who want to improve performance can
make their APIs lazy and emit Weld code for individual functions. Our runtime can then
optimize entire call graphs and produce fast native code without unnecessary
intermediate data materialization. Weld is essentially a just-in-time (JIT)
compilation system for analytics libraries.</p>

<p>In brief, Rust was a joy to work with. Its powerful pattern matching made
writing compiler optimization rules very easy, and we found that code that
compiled usually “just worked” because of the stringent checks Rust’s own
compiler performs on code the programmer writes. Additionally, writing C APIs
in Rust was also very easy; Rust provides good support and documentation for
doing this. While there are a few features the Rust developers are working on
which we hope appear in the stable compiler soon (namely, incremental
compilation and the <code class="highlighter-rouge">box</code> keyword), we wholeheartedly reccomend Rust to those
looking for a fun, powerful programming language for their next project.</p>

<p>Stay tuned for another blog post that describes Weld in greater detail. For
now, keep reading for our thoughts on writing Weld in Rust, and join the
discussion on Weld on our <a href="https://groups.google.com/forum/#!forum/weld-users">Google
Group</a>!</p>

<p><strong>Outline</strong></p>

<ul>
  <li><a href="#experiences-with-rust">Experiences with Rust</a>
    <ul>
      <li><a href="#implementing-rule-based-optimizations-with-pattern-matching">Implementing Rule-Based Optimizations with Pattern Matching</a></li>
      <li><a href="#handling-errors">Handling Errors</a></li>
      <li><a href="#rustc-compilation-times"><code class="highlighter-rouge">rustc</code> Compilation Times</a></li>
      <li><a href="#interfacing-with-c">Interfacing with C</a></li>
    </ul>
  </li>
  <li><a href="#summary">Summary</a></li>
</ul>

<h2 id="experiences-with-rust">Experiences with Rust</h2>

<p>Weld is written in around 12000 lines of Rust code. It includes a compiler with
a tokenizer, parser, the abstract syntax tree (AST) definition, transformations
on the AST, and a code generator targeting LLVM, as well as a C API for
interacting with the compiler. Rust’s excellent LLVM bindings (<code class="highlighter-rouge">llvm-sys</code>) made
generating and JIT compiling LLVM code particularly easy.</p>

<p><em>We used Rust v.1.14 (stable) when developing Weld.</em></p>

<h4 id="implementing-rule-based-optimizations-with-pattern-matching">Implementing Rule-Based Optimizations with Pattern Matching</h4>

<p>Weld’s optimizer takes an AST and applies a set of rule-based optimizations to it. These optimizations
find a subtree in the AST and replace it with a more efficient subtree.</p>

<p>Each expression in Weld is an <code class="highlighter-rouge">Expr</code> type:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Expr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TypeBounds</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">kind</span><span class="p">:</span> <span class="n">ExprKind</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c">// other fields omitted</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">ExprKind</code> is an <code class="highlighter-rouge">enum</code> which specifies the kind of expression:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">pub</span> <span class="k">enum</span> <span class="n">ExprKind</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">TypeBounds</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Literal</span><span class="p">(</span><span class="n">LiteralKind</span><span class="p">),</span>
    <span class="nf">Ident</span><span class="p">(</span><span class="n">Symbol</span><span class="p">),</span>
    <span class="nf">Negate</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">),</span>
    <span class="n">BinOp</span> <span class="p">{</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">BinOpKind</span><span class="p">,</span>
        <span class="n">left</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">right</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="c">// more expression kinds here</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Rust’s pattern matching makes writing transformations rules easy. 
We wrote a <code class="highlighter-rouge">transform</code> method for the <code class="highlighter-rouge">Expr</code> type which, given a function which
takes an <code class="highlighter-rouge">Expr</code> and returns an <code class="highlighter-rouge">Option&lt;Expr&gt;</code>, applies the function to each
node in the AST.  If the <code class="highlighter-rouge">Option</code> is <code class="highlighter-rouge">Some(e)</code>, the node to which the function
was applied is replaced by the expression <code class="highlighter-rouge">e</code>. If the <code class="highlighter-rouge">Option</code> is <code class="highlighter-rouge">None</code>, the
expression is not substituted. This allows us to express transforms on the AST
elegantly by defining a function which specifies a set of match rules and
then calling <code class="highlighter-rouge">transform</code>.</p>

<p>Below, we have a simple match rule which matches on two <code class="highlighter-rouge">i32</code> literals being summed. The expression is replaced by summing the 
integers at compile time and replacing the add operation with a single literal:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">// Replace, e.g., "1 + 2" with "3"</span>
<span class="n">expr</span><span class="nf">.transform</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="p">|</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">expr</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="n">BinOp</span><span class="p">{</span><span class="k">ref</span> <span class="n">kind</span><span class="p">,</span> <span class="k">ref</span> <span class="n">left</span><span class="p">,</span> <span class="k">ref</span> <span class="n">right</span><span class="p">}</span> <span class="o">=</span> <span class="n">expr</span><span class="py">.kind</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="nb">Add</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Literal</span><span class="p">(</span><span class="nf">I32Literal</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="o">=</span> <span class="n">left</span><span class="py">.kind</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Literal</span><span class="p">(</span><span class="nf">I32Literal</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">=</span> <span class="n">right</span><span class="py">.kind</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="n">Expr</span><span class="p">{</span>
                        <span class="n">ty</span><span class="p">:</span> <span class="nf">Scalar</span><span class="p">(</span><span class="n">I32</span><span class="p">),</span>
                        <span class="n">kind</span><span class="p">:</span> <span class="nf">I32Literal</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span>
                    <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>    
    <span class="p">}</span>
    <span class="nb">None</span>
<span class="p">});</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">transform</code> is taking a closure here. The nested <code class="highlighter-rouge">if let</code> statements destructure a sub-expression to build the match rule.
If we find a match, we replace the expression with an expression which adds the literal values.</p>

<p>One point of tedium is that we need to use <code class="highlighter-rouge">if let</code> statements to destructure each expression
instead of being able to “nest” destructuring structs. For example, a similar implementation in Scala is much more concise since
patterns are nested:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">expr</span><span class="o">.</span><span class="n">transform</span> <span class="o">{</span> 
    <span class="nc">BinOp</span><span class="o">(</span><span class="nc">Add</span><span class="o">,</span> <span class="nc">Literal</span><span class="o">(</span><span class="n">I32Literal</span><span class="o">(</span><span class="n">l</span><span class="o">)),</span> <span class="nc">Literal</span><span class="o">(</span><span class="n">I32Literal</span><span class="o">(</span><span class="n">r</span><span class="o">)))</span> <span class="k">=&gt;</span>
        <span class="nc">Expr</span><span class="o">(</span><span class="nc">Scalar</span><span class="o">(</span><span class="n">I32</span><span class="o">),</span> <span class="n">I32Literal</span><span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">))</span>
<span class="o">}</span>
</code></pre>
</div>

<p>The reason we cannot nest match rules in Rust is that each expression in our implementation is actually a <code class="highlighter-rouge">Box&lt;Expr&gt;</code>. <code class="highlighter-rouge">Box</code> is Rust’s
type designating heap allocated memory, and because we want to support in-place updates to the AST we want to use this type instead
of just <code class="highlighter-rouge">Expr</code>. Unfortunately, Rust doesn’t support nesting patterns for these boxed values, since the pattern would match on a <code class="highlighter-rouge">Box</code>
instead of the <code class="highlighter-rouge">Expr</code> (in the code above, <code class="highlighter-rouge">ref</code> dereferences the box). This causes deeply nested <code class="highlighter-rouge">if let</code> statements even for simple match rules.</p>

<p>Rust solves this problem using the <a href="https://doc.rust-lang.org/book/box-syntax-and-patterns.html"><code class="highlighter-rouge">box</code>
keyword</a>, which
allows matching on the <em>contents</em> of the <code class="highlighter-rouge">Box</code>. Unfortunately, this keyword is
not yet available in the stable version of the Rust compiler.</p>

<h4 id="handling-errors">Handling Errors</h4>

<p>Handling errors is a tedious undertaking in a systems project, and
especially in low-level projects written in C and C++. However, Rust’s <code class="highlighter-rouge">Result</code>
type makes it very easy. <code class="highlighter-rouge">Result&lt;T, U&gt;</code> is an enum with two variants: <code class="highlighter-rouge">Ok(T)</code> and
<code class="highlighter-rouge">Err(U)</code>. These variants specify whether a function call was successful (in
which case the function would return <code class="highlighter-rouge">Ok</code>) or caused an error (in which case it would return <code class="highlighter-rouge">Err</code>).</p>

<p>Most functions in the Weld implementation return a <code class="highlighter-rouge">Result</code>, which enables use
of the <code class="highlighter-rouge">try!</code> macro. This macro checks if the
<code class="highlighter-rouge">Result</code> is <code class="highlighter-rouge">Ok</code> or <code class="highlighter-rouge">Err</code>. If it is <code class="highlighter-rouge">Err</code>, it exits the function and returns the <code class="highlighter-rouge">Result</code>.
If it is <code class="highlighter-rouge">Ok</code>, it unwraps the value contained in the <code class="highlighter-rouge">Ok</code>. This
makes it easy to propagate errors deep in a call stack up to some place where
they can be presented to the user. As an example, the following code appears in Weld’s parser:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_program</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Program</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tokens</span> <span class="o">=</span> <span class="nd">try!</span><span class="p">(</span><span class="nf">tokenize</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
    <span class="c">// parse tokens</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">tokenize</code> method also returns
a <code class="highlighter-rouge">Result</code>. If tokenization fails, the first line of the function exits and
returns an error. Otherwise, <code class="highlighter-rouge">tokens</code> is set to the value contained in the <code class="highlighter-rouge">Ok</code> returned
by <code class="highlighter-rouge">tokenize</code>.</p>

<p>In all, <code class="highlighter-rouge">Result</code> and <code class="highlighter-rouge">try!</code> make error propagation very easy. We found
that Rust did a much nicer job in making error handling code (something every
program should do!) elegant when compared to the <code class="highlighter-rouge">errno</code>s and error codes C
programmers are accustomed to.</p>

<h4 id="rustc-compilation"><code class="highlighter-rouge">rustc</code> Compilation</h4>

<p>Our first stab at writing a parser for Weld’s IR used a parser-generator
library called <a href="https://crates.io/crates/lalrpop"><code class="highlighter-rouge">lalrpop</code></a>.  Unfortunately, one major
limitation of this library was the amount of code it generated. Because <code class="highlighter-rouge">lalrpop</code> (when we used it)
    created a parser with over 10000 lines of code, Rust took over a minute to compile it. This was partially caused
    by the lack of incremental compilation in stable Rust.
    These compile times took a significant toll on productivity especially since we modified the IR’s
    parser fairly often. Eventually, we opted to implement our own recursive descent
    parser from scratch to reduce the compilation time.</p>

<p>In general, we found that Rust code took some time to compile;
changing a single file and then running <code class="highlighter-rouge">cargo build</code> takes roughly 10 seconds
on a standard laptop, while <code class="highlighter-rouge">cargo build --release</code> (which enables compiler
optimizations) takes around a minute.  However, because of the copious
compile-time guarantees Rust makes in its language, we often found that
compiled code was working code; this certainly isn’t true in most C code we
write!</p>

<p>In addition, Rust has been looking into incremental computation <a href="https://blog.rust-lang.org/2016/09/08/incremental.html">for some time
now</a>; we hope this
feature makes it into the stable compiler soon.</p>

<h4 id="interfacing-with-c">Interfacing with C</h4>

<p>Weld interfaces with C by exposing its API as a set of C functions. This allows
Weld’s API to be called by languages such as Python, which have utilities for
calling C functions (e.g., Python’s <code class="highlighter-rouge">ctypes</code> module). An initial
concern with Rust was whether it would be easy to support exporting C-style
APIs easily; we quickly found that Rust had good support for this.</p>

<p>In Rust, a C function can be exported by using the <code class="highlighter-rouge">extern "C"</code> qualifier on a function, marking
it as public, and using the <code class="highlighter-rouge">#[no_mangle]</code> annotation:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="n">no_mangle</span><span class="p">]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">my_c_callable_function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello from Rust!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The above function will be exported and callable from C. The declaration of
this function in C would look as you might expect:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">my_c_callable_function</span><span class="p">();</span>
</code></pre>
</div>

<p>Rust also provides wrappers for C data types in the external <code class="highlighter-rouge">libc</code> crate. Weld
uses these to return integers and strings back into C:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">extern</span> <span class="n">crate</span> <span class="n">libc</span><span class="p">;</span>

<span class="cp">#[no_mangle]</span>
<span class="c">/// Returns an unsigned 64-bit int.</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">get_string</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">libc</span><span class="p">::</span><span class="n">uint64_t</span> <span class="p">{</span>
    <span class="mi">1</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Things get interesting when we need to pass richer data types from Rust to C.
Weld uses opaque handles (<code class="highlighter-rouge">void *</code> with a typedef) in its API to do this. The
<code class="highlighter-rouge">void *</code> pointers are heap-allocated Rust values (i.e., values with type
<code class="highlighter-rouge">Box&lt;T&gt;</code>). Of course, C doesn’t understand what a “<code class="highlighter-rouge">Box</code>” is, so we
need to acquire a raw pointer before passing it out of Rust.</p>

<p>One tricky thing here is that Rust figures out when it should release memory it
allocates. For example, a boxed value is freed when it goes out of scope.
When passing values to C, however, this isn’t exactly what we want; Rust
shouldn’t release a value when a <code class="highlighter-rouge">Box</code> goes out of scope, because some C code
might still be using its underlying data.</p>

<p>Rust gets around this with <code class="highlighter-rouge">Box</code>’s <code class="highlighter-rouge">into_raw</code> function. <code class="highlighter-rouge">into_raw</code>
automatically <em>forgets</em> about the heap allocated memory, so it can be passed
into C without fear of Rust deallocating it. When a heap allocated object is
passed back into C, we can use the <code class="highlighter-rouge">from_raw</code> function to reconstruct a <code class="highlighter-rouge">Box</code>
and tell Rust to treat it as an ordinary object it allocated. Alternatively, we can
just dereference the passed pointer in Rust and do operations on it. Note that both
of these operations are <code class="highlighter-rouge">unsafe</code> since Rust can’t make any guarantees about whether the
pointer is valid.</p>

<p>In all, Weld’s API looks something like the follows. For every type in the API,
Rust allocates boxed memory and casts it to a <code class="highlighter-rouge">*mut T</code> (a raw pointer) before
returning it. When a C caller passes the pointer back (as a raw pointer), we
use <code class="highlighter-rouge">from_raw</code> to reconstruct the Rust object, and then use the object. Below
is an example for the <code class="highlighter-rouge">WeldConf</code> type, which wraps a Rust <code class="highlighter-rouge">HashMap</code> and holds
configuration options.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">WeldConf</span> <span class="p">{</span>
    <span class="n">conf_map</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CString</span><span class="p">,</span> <span class="n">CString</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c">// other stuff</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="c">/// Return a new Weld configuration.</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">weld_conf_new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">WeldConf</span> <span class="p">{</span>
    <span class="c">// forgets the allocated value, get a raw ptr</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">WeldConf</span><span class="p">::</span><span class="nf">new</span><span class="p">()))</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="c">/// Return the number of configurations in the conf.</span>
<span class="k">pub</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">weld_conf_count</span><span class="p">(</span>
    <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">WeldConf</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">libc</span><span class="p">::</span><span class="n">uint64_t</span> <span class="p">{</span>
    
    <span class="c">// Dereference the WeldConf and convert it to a </span>
    <span class="c">// reference.</span>
    <span class="k">let</span> <span class="n">conf</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">ptr</span><span class="p">;</span>

    <span class="c">// do stuff with conf; it's a regular Rust object.</span>
    <span class="n">conf</span><span class="py">.conf_map</span><span class="nf">.count</span><span class="p">()</span>
<span class="p">}</span>

<span class="cp">#[no_mangle]</span>
<span class="c">/// Frees a configuration.</span>
<span class="k">pub</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">weld_conf_free</span><span class="p">(</span>
    <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">WeldConf</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// The value is reconstructed and then dropped</span>
    <span class="c">// (since it goes out of scope).</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In C, the header file declaring the above API looks like this:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="c1">// The opaque handle.
</span><span class="k">typedef</span> <span class="kt">void</span><span class="o">*</span> <span class="n">weld_conf_t</span><span class="p">;</span>

<span class="c1">// Returns a new weld configuration.
</span><span class="n">weld_conf_t</span> <span class="n">weld_conf_new</span><span class="p">();</span>

<span class="c1">/// Return the number of configurations in the conf.
</span><span class="kt">uint64_t</span> <span class="n">weld_conf_count</span><span class="p">(</span><span class="n">weld_conf_t</span> <span class="n">ptr</span><span class="p">);</span>

<span class="c1">// Frees a configuration.
</span><span class="kt">void</span> <span class="n">weld_conf_free</span><span class="p">(</span><span class="n">weld_conf_t</span> <span class="n">ptr</span><span class="p">);</span>
</code></pre>
</div>

<p>In general, despite its many language features Rust is still able to seamlessly
integrate with existing C programs. While developers need to be cognizant of
when Rust frees memory to prevent dangling pointers and leaks, the Rust docs do
a fantastic job documenting how to avoid these problems.</p>

<h2 id="summary">Summary</h2>

<p>To summarize, implementing Weld in Rust was definitely a positive experience. As
other Rust users have reported at length, the language has a larger learning
curve than other languages, but after grappling with the borrow checker for a
few days the advantages of the language begin to outweigh its complexity.</p>

<p>In conclusion:</p>

<ul>
  <li>Pattern matching and Rust’s expressive <code class="highlighter-rouge">enum</code>s are a great fit for engineering a compiler.</li>
  <li>Error handling code is very elegantly expressed using <code class="highlighter-rouge">Result</code>.</li>
  <li>Compilation times are slow for large files, but the guarantees Rust provides
means bugs such as segfaults are non-existent (barring functions written using
the FFI); generally, code that compiles is very likely to just work.</li>
  <li>The lack of the <code class="highlighter-rouge">box</code> keyword makes matching on recursive data types such as
ASTs where each node is a <code class="highlighter-rouge">Box&lt;T&gt;</code> unwieldy, since programmers are stuck using
nested <code class="highlighter-rouge">if let</code> statements. We hope this feature makes it to stable Rust soon.</li>
  <li>Interfacing with C is intuitive, though it require some manual memory
management. Nonetheless, found that the relevant libraries are very well documented.</li>
  <li>The <code class="highlighter-rouge">llvm-sys</code> crate, which provides wrappers around the LLVM libraries, made code generation
in our compiler very easy.</li>
</ul>

<p>We hope this blog post helps other systems developers in evaluating whether
Rust is a good choice for them, in particular when writing libraries which need
to be called by non-Rust code.</p>


		
	</div>
</article>



<div id="disqus_thread"></div>
    <script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
    var disqus_config = function () {
        this.page.url = "/blog/rust";  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = "/rust"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://dawn-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>




	  </main>
		
		  <!-- Pagination links -->
      

	  </div>
	    
	    <!-- Footer -->
	    <footer><span>@2017 - Stanford University. Theme based on <a href=https://github.com/dyutibarma/monochrome>Monochrome</a>.</span></footer>


	    <!-- Script -->
      <script src="/blog/js/main.js"></script>	


	</div>
</body>

                                    

</html>
